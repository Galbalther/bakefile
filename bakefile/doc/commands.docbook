<chapter id="ch.commands">
    <title>Commands Reference</title>
    <para id="commands">
        Commands are top-level makefile constructs. They have following form:
        <programlisting><![CDATA[
<COMMAND [PROPERTY="VALUE", ...]>
    CONTENT
</COMMAND>
]]></programlisting>
        Here, <varname>CONTENT</varname> is either a text value (as in e.g.
        <xref linkend="cmd.set"/>) or XML subtree.
    </para>


    <section>
      <title>Makefile Commands</title>

    
      <!-- //////////////////          set           ////////////////// -->


      
      <section id="cmd.set" xreflabel="set">
          <title>set</title>
          <para>
            Sets a variable. There are two forms of the command. The first
            one if for setting variables unconditionally:
            <programlisting><![CDATA[
<set var="NAME" [append="APP"] [prepend="PREP"] [overwrite="OVERWRITE"]
     [scope="SCOPE"] [make_var="MAKEVAR"] [hints="HINTS"]>
  VALUE
</set>
  ]]></programlisting>
            The other one resembles <emphasis>switch</emphasis> statement known
            from C and is used to set the variable to one of possible values
            depending on certain condition:
            <programlisting><![CDATA[
<set var="NAME" [append="APP"] [prepend="PREP"] [overwrite="OVERWRITE"]
     [scope="SCOPE"] [make_var="MAKEVAR"] [hints="HINTS"]>
  <if cond="COND">VALUE</if>
  [
  <if cond="COND">VALUE</if>
  ...
  ]
</set>
  ]]></programlisting>
            If the second from is used then the variable is set to value from
            the first <function>if</function> node whose condition is met, or
            to empty string if no condition is met.
            Note that conditions within one <function>set</function> command
            <emphasis>must be mutually exclusive.</emphasis>
          </para>
          <para>
              The value is any text that may contain
              <link linkend="concept.variables">variable expansions</link>.
          </para>
          <para>
              If an <link linkend="concept.option">option</link>
              with same name exists, the variable takes precedence and the
              option is shadowed by it. This behaviour allows you to hardcode
              values for some ruleset's options in the makefile or to specify
              the value on command line when running Bakefile.
          </para>
          <variablelist id="cmd.set.params">
              <title>Parameters:</title>
              <varlistentry>
                  <term>var</term>
                  <listitem>
                      <para>
                          Name of the variable to assign the value.
                     </para>
                      <para role="default">
                          Required parameter
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>append</term>
                  <listitem>
                      <para>
                          If 1, the value is appended to previous value of the
                          variable if it is already defined (otherwise the
                          command behaves as if append=0).
                          Following two <function>set</function>
                          commands are equivalent:
                          <programlisting><![CDATA[
<set var="FOO" append="1">something</set>
<set var="FOO">$(FOO) something</set>
]]></programlisting>
                      </para>
                      <para role="default">
                          Default value: 0
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>prepend</term>
                  <listitem>
                      <para>
                          If 1, the value is prepended in front of previous 
                          value of the variable if it is already defined
                          (otherwise the command behaves as if prepend=0).
                          Following two <function>set</function>
                          commands are equivalent:
                          <programlisting><![CDATA[
<set var="FOO" prepend="1">something</set>
<set var="FOO">something $(FOO)</set>
]]></programlisting>
                      </para>
                      <para role="default">
                          Default value: 0
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>cond</term>
                  <listitem>
                      <para>
                          If present, the variable is set only if the condition
                          is met. If the condition evaluates to 0, the variable
                          is not set, if it evaluates to 1, the variable is set.
                          If condition's value can't be determined at the time
                          of makefile processing, a
                          <link linkend="concept.condvar">conditional variable
                          </link> is created instead of ordinary variable.
                          See <xref linkend="concept.conditions"/> for more
                          details.
                          <programlisting><![CDATA[
<set var="FILES">
  <if cond="BUILD=='debug'">foo_dbg.c</if>
  <if cond="BUILD=='release'">foo.c</if>
</set>
]]></programlisting>
                          The condition can also value special value
                          <literal>target</literal>, which can only be used
                          within <link linkend="concept.target">target</link>
                          specification. In that case parent
                          <link linkend="targets">target's condition</link>
                          is used (or <literal>1</literal> if there's no
                          condition set on the target).
                          The condition can also be "<literal>target
                            and</literal><emphasis>condexpr</emphasis>" in
                          which case target's condition (if any) is combined
                          with <emphasis>condexpr</emphasis>.
                      </para>
                      <para>
                        The string with condition may itself be a
                        constant expression, so you can write this:
                        <programlisting><![CDATA[
<set var="IsRelease">=='release'</set>
<set var="CondDebug">BUILD=='debug'</set>
<set var="FILES">
  <if cond="BUILD$(IsRelease)">foo_dbg.c</if>
  <if cond="$(CondDebug)">foo.c</if>
</set>
]]></programlisting>
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                <term>overwrite</term>
                  <listitem>
                      <para>
                        If set to 0 and variable with this name already exists,
                        then it's value is not changed (the default is to change
                        it).
                      </para>
                      <para role="default">
                        Default value: 1
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                <term>scope</term>
                  <listitem>
                    <para>
                      Specify scope of variable being set. Possible values are
                      <varname>local</varname> (current target if the command is
                      applied on a target, same as <varname>global</varname>
                      otherwise), <varname>global</varname> or a name of
                      existing target (in which case the variable is set on
                      that target).
                    </para>
                    <para>
                      Can't be used with conditional variables.
                    </para>
                    <para role="default">
                      Default value: local
                    </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>make_var</term>
                  <listitem>
                      <para>
                          If set to <literal>1</literal>, then the variable
                          is preserved in the makefile instead of being
                          substituted by Bakefile. This happens only if the
                          output format supports it
                          (<varname>FORMAT_HAS_VARIABLES</varname> is set to
                          <literal>1</literal>) and if variable's value is not
                          empty string. This settings is useful
                          together with frequently used variables with long
                          values, it helps reduce size of generated makefiles.
                      </para>
                      <para role="default">
                          Default value: 0
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>hints</term>
                  <listitem>
                      <para>
                          Comma-separated list of hint keywords. These hints
                          are optional and Bakefile can (but doesn't have to)
                          use them to better format generated makefiles. So
                          far only <literal>files</literal> hint is supported.
                          It tells Bakefile that the variable holds list of
                          files and if it is either make or conditional
                          variable, it is formatted in such way that only
                          one file per line is written to the output (and
                          therefore adding or removing files does only cause
                          small differences).
                      </para>
                      <para role="default"></para>
                  </listitem>
              </varlistentry>
          </variablelist>
          <para role="example">
              Example:
              <programlisting><![CDATA[
<set var="APP_VERSION">1.0.3</set>
<set var="TAR_NAME">app-$(APP_VERSION).tar.gz</set>
]]></programlisting>
          </para>
          <para role="seealso">
              See also: <xref linkend="cmd.unset"/>
          </para>
      </section>




      
      <!-- //////////////////         unset          ////////////////// -->

      
      
      
      <section id="cmd.unset" xreflabel="unset">
          <title>unset</title>
          <para>
              Unsets variable previously set by <xref linkend="cmd.set"/>. Note
              that you can only unset a <emphasis>variable</emphasis>, not
              an <link linkend="concept.option">option</link> or 
              <link linkend="concept.condvar">conditional variable</link>.
              <programlisting><![CDATA[
<unset var="NAME"/>]]>
  </programlisting>
          </para>
          <variablelist id="cmd.unset.params">
              <title>Parameters:</title>
              <varlistentry>
                  <term>var</term>
                  <listitem>
                      <para>
                          The meaning is same as in
                          <link linkend="cmd.set.params">set's properties</link>.
                      </para>
                  </listitem>
              </varlistentry>
          </variablelist>
      </section>


      

      
      <!-- //////////////////       option          ////////////////// -->

      
      
      <section id="cmd.option" xreflabel="option">
        <title>option</title>
        <para>
          Adds an <link linkend="concept.option">option</link>
          to the makefile.
          <programlisting><![CDATA[
<option name="NAME" [never_empty="NEVER_EMPTY"] [category="CATEGORY"]>
  [<default-value>DEFVALUE</default-value>]
  [<description>DESC</description>]
  [<values>VALUES</values>]
  [<values-description>VALUES_DESC</values-description>]
</option>
]]></programlisting>
          <varname>NAME</varname> is variable name under which the option is
          used in the makefile (using same syntax as when expanding
          <link linkend="concept.variables">variables</link>).
          <varname>NAME</varname> is required, the rest of parameters is
          optional.
        </para>
        <para>
          <varname>DEFVALUE</varname> is default value of the
          option, if appliable. It can be used by format backends that don't
          support options and it is used as default in those that do. Use it
          whenever possible.
        </para>
        <para>
          <varname>NEVER_EMPTY</varname> may be set to <literal>1</literal> to
          tell Bakefile that it can treat the option as non-empty variable.
          This is useful only rarely in situations when Bakefile requires some
          non-empty value as tag's argument.
        </para>
        <para>
          <varname>CATEGORY</varname> may be set to provide Bakefile
          additional information about the option. Certain operations
          (typically substitutions) may fail when applied to options unless
          all of its possible values are known. Because many tags use
          substitutions internally, this can be very limiting; the category
          hint can be used to work around most common problems.

          Possible values are <literal>unspecified</literal> (the default)
          and <literal>path</literal>, which indicates that the option will
          contain valid <emphasis>native</emphasis>, non-empty path name. An
          option with category set to <literal>path</literal> can be used as
          argument to tags like <xref linkend="tag.include"/>.
        </para>
        <para>
          <varname>DESC</varname> is human-readable description of the option,
          for use in comments.
        </para>
        <para>
          <varname>VALUES</varname> is comma-separated list of all
          possible values the option can have. It is used by backends that
          don't support options (such as Visual C++ project files) to generate
          all possible configurations. It's use is highly recommended.
        </para>
        <para>
          <varname>VALUES_DESC</varname> is comma-separated list of
          single-word description of corresponding values. It may be used
          only if <varname>VALUES</varname> were specified and both
          lists must have same length. These descriptions will show up
          in formats that don't support conditions, such as Visual C++
          projects (the project will contain several configurations that
          will be described using these words).
        </para>
      </section>




      
      <!-- //////////////////      template         ////////////////// -->

      
      
      <section id="cmd.template" xreflabel="template">
        <title>template</title>
        <para>
          Defines new <link linkend="concept.template">template</link>.
          <programlisting><![CDATA[
<template id="NAME" [template="TEMPLATE,..."]>
  SPECIFICATION
</template>]]>
  </programlisting>
          Template definition is syntactically identical to
          <link linkend="targets">target definition</link>.
          <varname>template</varname> is optional comma-separated list of
          templates this template derives from and
          <varname>SPECIFICATION</varname> may contain the very same things that
          target node.
        </para>
        <para>
          Content of <function>template</function> node is
          <emphasis>not</emphasis> processed by Bakefile when it is encountered
          in makefile. It is stored in templates dictionary instead. When a
          target that derives from the template is encountered, the template
          is inserted before target's content.
        </para>
        <para>
          For example consider this makefile fragment:
          <programlisting><![CDATA[
<template id="t1">
  <define>NAME=$(id)</define>
</template>
<template id="t2">
  <include>../headers</include>
</template>

<exe id="app" template="t1,t2">
  <sources>hello.c</sources>
</exe>
]]></programlisting>
          It looks like this after templates expansion:
          <programlisting><![CDATA[
<exe id="app" template="t1,t2">
  <define>NAME=$(id)</define>
  <include>../headers</include>
  <sources>hello.c</sources>
</exe>
]]></programlisting>
        </para>
      </section>



      
      <!-- //////////////////      using          ////////////////// -->

      
      
    <section id="cmd.using" xreflabel="using">
      <title>using</title>
      <para>
        This commands is used to declare what modules the makefile requires.
        See more about modules in <xref linkend="concept.modules"/>.
              <programlisting><![CDATA[
<using module="MODULE1[,MODULE2[,...]]"/>]]>
  </programlisting>
      </para>
      <para>
        The effect of <function>using</function> is as follows: the modules are
        added to the list of used modules (unless they are already in it) and
        additional ruleset files are loaded from
        <link linkend="searchpaths">Bakefile search paths</link>. Name of every
        file in every search path is decomposed into components by making every
        subdirectory name a component and splitting the basename into components
        by separating it on hyphens. A file is included as soon as all
        components of its name appear in the list of used modules. The inclusion
        behaves indentically to <xref linkend="cmd.include"/>.
      </para>
      <para>
        Consider this structure of ruleset files:
        <programlisting>
python/common.bakefile        # python,common
python/cxx.bakefile           # python,cxx
cxx-common.bakefile           # cxx,common
cxx-qt.bakefile               # cxx,qt
qt/python.bakefile            # qt,python
qt/cxx-python.bakefile        # qt,cxx,python</programlisting>
        Anotated makefile fragment illustrates order of modules loading:
        <programlisting><![CDATA[
<using module="python"/>
<!-- python/common.bakefile loaded -->

<using module="cxx"/>
<!-- cxx-common.bakefile loaded -->
<!-- python/cxx.bakefile loaded -->

<using module="qt"/>
<!-- qt/python.bakefile loaded -->
<!-- cxx-qt.bakefile loaded -->
<!-- qt/cxx-python.bakefile loaded -->
]]></programlisting>
      </para>
      <para>
        (Note that module "common" and module named after the target format are
        always used. Therefore ruleset files
        <filename>common/MODULE.bakefile</filename> are always loaded if they exist.)
      </para>
      <para>
        The command may be used repeatedly in the makefile or included files.
        Repeating the <function>using</function> command with module that was
        already added to the list of used modules with <function>using</function>
        has no effect.
      </para>
      <variablelist>
        <title>Parameters:</title>
        <varlistentry>
          <term>module</term>
            <listitem>
              <para>
                Comma-separated list of modules to use.
              </para>
            </listitem>
          </varlistentry>        
        </variablelist>
        <para>
          In this example the makefile uses Gettext, Python and Pascal modules:
          <programlisting><![CDATA[
<using module="gettext,python"/>
<using module="pascal"/>
]]></programlisting>
        </para>
    </section>



      
      <!-- //////////////////      include          ////////////////// -->

      
      
    <section id="cmd.include" xreflabel="include">
      <title>include</title>
      <para>
        Includes Bakefile file. This is done by loading the file and
        processing it immediately after <function>include</function> command
        is encountered during parsing. The effect of using
        <function>include</function> is identical to including content of the
        file in place of the
        <function>include</function> command.
        <programlisting><![CDATA[
<include file="FILENAME" [ignore_missing="0|1"]/>
]]></programlisting>
      </para>
      <variablelist>
        <title>Parameters:</title>
        <varlistentry>
          <term>file</term>
            <listitem>
              <para>
                Name of the file to include. The filename may be either absolute
                or relative. In the latter case, it is looked up relative to the
                location of the makefile that contains the
                <function>include</function> command and if that fails,
                relative to standard Bakefile search paths.
              </para>
            </listitem>
         </varlistentry>
        <varlistentry>
          <term>ignore_missing</term>
            <listitem>
              <para>
                If set to 1, it is not an error if the file can't be found. If
                0, Bakefile will abort with an error if it can't find the file.
              </para>
              <para role="default">
                Default value: 0
              </para>
            </listitem>
         </varlistentry>
      </variablelist>
    </section>

          

      
      <!-- //////////////////          if            ////////////////// -->

      
      
      <section id="cmd.if" xreflabel="if">
        <title>if</title>
        <para>
          Conditionally process part of the makefile.
          <programlisting><![CDATA[
<if cond="WEAKCONDITION">
  ...statements...
</if>
]]></programlisting>
          The condition must be
          <link linkend="concept.conditions.weak">weak</link>. If it evaluates to
          1 nodes under <function>if</function> node are processed as if they
          were toplevel nodes. If it evaluates to 0, they are discarded.
        </para>
      </section>
      
      
      
      
      <!-- //////////////////     fragment       ////////////////// -->

      
      <section id="cmd.fragment" xreflabel="fragment">
        <title>fragment</title>
        <para>
          Inserts text into generated native makefile verbosely, so that it is
          possible to include things not yet supported by Bakefile in the
          makefiles. The text can be either read from a file or is taken from
          command node's content. Variables are <emphasis>not</emphasis>
          substituted in fragment's content, it is copied to the makefile 
          as-is, with no changes.
          <informaltable>
            <tgroup cols='3'>
              <thead>
                <row>
                  <entry>Parameter</entry>
                  <entry>Description</entry>
                  <entry>Required/Default value</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry role="paramname">format</entry>
                  <entry>
                    Output format the fragment is for.
                  </entry>
                  <entry role="default">required</entry>
                </row>
                <row>
                  <entry role="paramname">file</entry>
                  <entry>
                    Read the fragment from file.
                  </entry>
                  <entry role="default">no file, text is embedded</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>

      
      
      <!-- //////////////////     requires       ////////////////// -->

      
      <section id="cmd.requires" xreflabel="requires">
        <title>requires</title>
        <para>
          Declares bakefile's requirements that the installed bakefile
          version must meet to be able to correctly generate native makefiles
          from it.
          <informaltable>
            <tgroup cols='3'>
              <thead>
                <row>
                  <entry>Parameter</entry>
                  <entry>Description</entry>
                  <entry>Required/Default value</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry role="paramname">version</entry>
                  <entry>
                    Minimal required version of Bakefile, e.g.
                    <literal>0.1.1</literal>.
                  </entry>
                  <entry role="default">optional</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          Example:
          <programlisting><![CDATA[
<!-- refuse to run with Bakefile < 0.5.0,
     it's missing feature foo: -->
<requires version="0.5.0"/>
]]></programlisting>
        </para>
      </section>



      
      <!-- //////////////////        error          ////////////////// -->

      
      
      
      <section id="cmd.error" xreflabel="error">
          <title>error</title>
          <para>
              Reports error to output and exits. This command is useful for
              adding sanity checks to bakefiles (both user bakefiles and
              format definitions).
              <programlisting><![CDATA[
<!-- This code prevents creation of rules
     for console mode apps: -->
<define-tag name="app-type" rules="exe">
  <if cond="value == 'console'">
    <error>
      Windows CE doesn't support console applications.
      </error>
  </if>
</define-tag>]]>
</programlisting>
          </para>
      </section>

      <!-- //////////////////        echo          ////////////////// -->




      <section id="cmd.echo" xreflabel="echo">
          <title>echo</title>
          <para>
            Prints the text in tag's value to output and,
            unlike <xref linkend="cmd.error"/>,
            continues processing. This command is useful for debugging
            bakefiles (e.g. by printing variable values or adding progress
            messages).
          </para>
          <para>
            Note that if a variable is used in the text, it must evaluate to
            a constant (i.e. <link linkend="concept.condvar">conditional
            variables</link> or <link linkend="concept.option">options</link>
            cannot be used).
            <informaltable>
              <tgroup cols='3'>
                  <thead>
                  <row>
                      <entry>Parameter</entry>
                      <entry>Description</entry>
                      <entry>Default value</entry>
                  </row>
                  </thead>
                  <tbody>
                  <row>
                      <entry role="paramname">level</entry>
                      <entry>
                        Can be <literal>warning</literal>
                        (in which case the message is printed to
                        stderr and prefixed with <literal>WARNING:</literal>),
                        <literal>verbose</literal> (in which case the
                        message is printed only when <xref
                        linkend='man.bakefile'/> is run with
                        <literal>--verbose</literal> argument) or
                        <literal>normal</literal> (message is printed
                        in any case to stdout).
                      </entry>
                      <entry role="default"><literal>normal</literal></entry>
                  </row>
                  </tbody>
              </tgroup>
            </informaltable>

            Example:

              <programlisting><![CDATA[
<!-- Show the content of the variable X -->
<set var="X">$(someComplexFunction())</set>
<echo>The content of the X variable is: $(X)</echo>]]>
</programlisting>
          </para>
      </section>





      
  
  
      
  
  
  
    </section>
    
    
    <section>
      <title>Commands for Extending Bakefile</title>

      
      <!-- //////////////////     define-rule          ////////////////// -->

      
      <section id="cmd.define-rule" xreflabel="define-rule">
        <title>define-rule</title>
        <para></para>
      </section>
          


      
      <!-- //////////////////     define-tag         ////////////////// -->

      
      <section id="cmd.define-tag" xreflabel="define-tag">
        <title>define-tag</title>
        <para></para>
      </section>

    
      <!-- //////////////////     add-target         ////////////////// -->

      
      <section id="cmd.add-target" xreflabel="add-target">
        <title>add-target</title>
        <para></para>
      </section>
      
      
      
      <!-- //////////////////     modify-target       ////////////////// -->

      
      <section id="cmd.modify-target" xreflabel="modify-target">
        <title>modify-target</title>
        <para></para>
      </section>

      
            
      <!-- //////////////////       output       ////////////////// -->

      
      <section id="cmd.output" xreflabel="output">
        <title>output</title>
        <para>
          Bakefile uses this command to specify what files a format produces.
          Output is generated only as the result of
          <function>output</function> command's presence in ruleset.
          <informaltable>
            <tgroup cols='3'>
              <thead>
                <row>
                  <entry>Parameter</entry>
                  <entry>Description</entry>
                  <entry>Required/Default value</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry role="paramname">file</entry>
                  <entry>
                    The file where output goes. Commontly used
                    value is <literal>$(OUTPUT_FILE)</literal>.
                  </entry>
                  <entry role="default">required</entry>
                </row>
                <row>
                  <entry role="paramname">writer</entry>
                  <entry>
                    Name of Empy template that is used to generated the
                    output.
                  </entry>
                  <entry role="default">required</entry>
                </row>
                <row>
                  <entry role="paramname">method</entry>
                  <entry>
                    <para>
                      Method of combining generated output with existing
                      content of the file. The default is
                      <literal>replace</literal>, which overwrites the file.
                    </para>
                    <para>
                      <literal>mergeBlocks</literal> divides both the old and
                      the new file's content into blocks that begin with block
                      signature like this:
                      <programlisting>### beging block <emphasis>BLOCKNAME</emphasis> ###</programlisting>
                      Blocks of the new content are copied over to the file,
                      replacing old copies of the blocks, but blocks that are
                      not present in new content are preserved. This can be used
                      e.g. to merge configuration settings from several
                      makefiles.
                    </para>
                    <para>
                      <literal>mergeBlocksWithFilelist</literal> works
                      similarly to <literal>mergeBlocks</literal>, but it
                      includes list of input files that generated the block in
                      the output and ensures that blocks that have no
                      generator (e.g. because user's bakefiles changed and no
                      longer cause some piece of code to be generated) are
                      removed from the output. The list of files is added to
                      block name like this:
                      <programlisting>### beging block
                      <emphasis>BLOCKNAME[file1.bkl,file2.bkl]</emphasis> ###</programlisting>
                    </para>
                    <para>
                      <literal>insertBetweenMarkers</literal> takes first and
                      last line of generated output, finds them in the output
                      file (which must exist and must contain them) and
                      inserts generated content between them.
                    </para>
                  </entry>
                  <entry role="default">
                    <literal>replace</literal>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </para>
      </section>


      
            
    </section>
        
</chapter>
