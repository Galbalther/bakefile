<?xml version="1.0" ?>
<!-- $Id$ -->

<makefile>
    
    <include file="win32.bkl"/>
    
    <set var="__DEFINE_ARG">-D</set>
    <set var="__INCLUDE_ARG">-I</set>
    <set var="__LIB_ARG">%s.lib</set>
    <set var="__LIBDIR_ARG">-L</set>

    <set var="__DEFAULT_CC">bcc32</set>
    <set var="__DEFAULT_CXX">bcc32</set>
    <set var="__DEFAULT_CFLAGS"></set>
    <set var="__DEFAULT_CPPFLAGS"></set>
    <set var="__DEFAULT_CXXFLAGS"></set>
    <set var="__DEFAULT_LDFLAGS"></set>
    
    <set var="__LINKER_CC" eval="0">ilink32 -Tpe</set>
    <set var="__LINKER_CXX" eval="0">ilink32 -Tpe</set>
    <set var="__DLL_LINKER_CC" eval="0">ilink32 -Tpd</set>
    <set var="__DLL_LINKER_CXX" eval="0">ilink32 -Tpd</set>

    <!-- basic compiler/linker flags: -->
    <set var="__FLAG_EXE_CONSOLE" eval="0">-ap</set> <!-- -tC -->
    <set var="__FLAG_EXE_GUI" eval="0">-aa</set> <!-- -tW -->
    <set var="__FLAG_DEBUG_ON">-v</set>
    <set var="__FLAG_DEBUG_ON_LINKER">-v</set>
    <set var="__FLAG_DEBUG_OFF">-v-</set>
    <set var="__FLAG_DEBUG_OFF_LINKER">-v-</set>
    <set var="__FLAG_OPTIMIZE_OFF">-Od</set>
    <set var="__FLAG_OPTIMIZE_SIZE">-O1</set>
    <set var="__FLAG_OPTIMIZE_SPEED">-O2</set>
    <set var="__FLAG_ARCH_I386">-3</set>
    <set var="__FLAG_ARCH_I486">-4</set>
    <set var="__FLAG_ARCH_I586">-5</set>
    <set var="__FLAG_ARCH_I686">-6</set>
    <set var="__FLAG_USE_PCH">-H -Hs</set>
    <set var="__FLAG_PCH_FILE">-H=%s.csm</set>
    <set var="__FLAG_SINGLE_THREADING"/>
    <set var="__FLAG_MULTI_THREADING">-tWM</set>
    <!-- FIXME: -tWR sets -tW as well, so it must be before -tC !! -->


    <!-- rules building blocks: -->
    
    <template id="__commands_templ_C">
        <set var="__COMPILE_C_CMD" eval="0">
            $(CC) -c -P- -o$@ $(__cflags) $**
        </set>
    </template>
    
    <template id="__commands_templ_CXX">
        <set var="__COMPILE_CXX_CMD" eval="0">
            $(CXX) -c -P -o$@ $(__cxxflags) $**
        </set>
    </template>

    <!--
    NB: We deal with the ilink32 mess here. We can't use simple linking
        because it doesn't allow us to embed resources. ilink32 requires
        that both startup object file and C RTL are specified explicitly,
        and we must come with correct names.

        Borland's startup objects are:
          c0d32.obj         windowed app DLL
          c0d32w.obj        DLL, wide char support
          c0d32x.obj        console DLL
          c0w32.obj         GUI app
          c0w32w.obj        GUI app, wide char support
          c0x32.obj         console app
          c0x32w.obj        console app, wide char support

        C runtime libs are:
          cw32.lib          static
          cw32i.lib         dynamic (import lib for DLL RTL)
          cw32mt.lib        static multi-threaded
          cw32mti.lib       dynamic multi-threaded

        FIXME - No idea what's the different between console and win DLL is,
                so we currently ignore it. Wide char support stuff is not
                used either, it doesn't seem to make a difference.
    -->
    
    <set var="__exe_baser">__borland_exe</set>
    <set var="__dll_baser">__borland_dll</set>
    <set var="__lib_baser">__borland_comp</set>

    <define-rule name="__borland_comp">
        <template>
            <set var="__rtldll_flag" eval="0"/>
            <set var="__startup_obj_type">x</set> <!-- console app -->
            <set var="__rtl_i"/>
            <set var="__rtl_mt"/>
            <set var="__startup" eval="0">c0$(__startup_obj_type)32.obj</set>
            <set var="__rtl" eval="0">cw32$(__rtl_mt)$(__rtl_i).lib</set>
            <cppflags>$(__rtldll_flag)</cppflags>
        </template>
        <define-tag name="runtime-libs">
            <set var="__rtldll_flag">
                $(substituteFromDict(value, {'static':'', 'dynamic':'-tWR'}))
            </set>
            <set var="__rtl_i">
                $(substituteFromDict(value, {'static':'', 'dynamic':'i'}))
            </set>
        </define-tag>
        <define-tag name="threading">
            <set var="__rtl_mt">
                $(substituteFromDict(value, {'multi':'mt', 'single':''}))
            </set>
        </define-tag>
    </define-rule>
    
    <define-rule name="__borland_dll" extends="__borland_comp">
        <template>
            <set var="__startup_obj_type">d</set> <!-- for DLL -->
        </template>
    </define-rule>
    <define-rule name="__borland_exe" extends="__borland_comp">
        <define-tag name="app-type">
            <set var="__startup_obj_type">
                $(substituteFromDict(value, {'console':'x','gui':'w'}))
            </set>
        </define-tag>
    </define-rule>
    
    
    <template id="__commands_templ">
        <!-- 
        NB: Borland make has builtin support for response files in the form of
            "&&|content of response file|" (where | can be any character).
            Borland tools use "@responsefile" syntax to use resp. file. This
            explains somehow cryptic syntax below.

            Note that there must be linefeed after first | and the second |
            must be alone on and at the beginning of the line (borland.empy
            takes care of this part).
            
            (We have to use response file because of windows command
            line length limitation.)
            -->
        <set var="__win32res"/>
        <set var="__LINK_EXE_CMD" eval="0">
            $(__linker) $(__ldflags) @&amp;&amp;|
            $(__startup) $(__objects),$@,,$(__ldlibs) $(__rtl),,$(__win32res)
            |
        </set>        
        <set var="__LINK_LIB_CMD" eval="0">
            if exist $@ del $@
            tlib /a $@ @&amp;&amp;|
            $(__objects)
            |
        </set>
        <set var="__LINK_DLL_CMD" eval="0">
            $(__dll_linker) $(__ldflags) @&amp;&amp;|
            $(__startup) $(__objects),$@,,$(__ldlibs) $(__rtl),,$(__win32res)
            |
            implib $(__targetdir)$(__libname) $@
        </set>
    </template>
    
    <template id="__subproject_templ">
        <set var="__MAKE_SUBPROJECT_CMD" eval="0">
            (cd $(__subdir) &amp;&amp; \$(MAKE) $(__subtarget))
        </set>
        <set var="__INSTALL_SUBPROJECT_CMD" eval="0">
            (cd $(__subdir) &amp;&amp; \$(MAKE) install)
        </set>
        <set var="__CLEAN_SUBPROJECT_CMD" eval="0">
            (cd $(__subdir) &amp;&amp; \$(MAKE) clean)
        </set>
    </template>

</makefile>
